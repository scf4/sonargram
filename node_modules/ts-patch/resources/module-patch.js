(function () {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }

    /* ****************************************************************************************************************** */
    // region: Constants
    /* ****************************************************************************************************************** */
    var diagnosticMap = new WeakMap();
    // endregion
    /* ********************************************************************************************************************
     * Helpers
     * ********************************************************************************************************************/
    function diagnosticExtrasFactory(program) {
        var diagnostics = diagnosticMap.get(program) || diagnosticMap.set(program, []).get(program);
        var addDiagnostic = function (diag) { return diagnostics.push(diag); };
        var removeDiagnostic = function (index) { diagnostics.splice(index, 1); };
        return { addDiagnostic: addDiagnostic, removeDiagnostic: removeDiagnostic, diagnostics: diagnostics };
    }
    var getCurrentLibrary = function () { return require('path').basename(__filename, require('path').extname(__filename)); };

    var fs$1 = require('fs');

    var _rollupPluginShim1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': fs$1
    });

    var path$1 = require('path');

    var _rollupPluginShim2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': path$1
    });

    var caller = function () {
        // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
        var origPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = function (_, stack) { return stack; };
        var stack = (new Error()).stack;
        Error.prepareStackTrace = origPrepareStackTrace;
        return stack[2].getFileName();
    };

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    function getCjsExportFromNamespace (n) {
    	return n && n['default'] || n;
    }

    var pathParse = createCommonjsModule(function (module) {

    var isWindows = process.platform === 'win32';

    // Regex to split a windows path into into [dir, root, basename, name, ext]
    var splitWindowsRe =
        /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;

    var win32 = {};

    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }

    win32.parse = function(pathString) {
      if (typeof pathString !== 'string') {
        throw new TypeError(
            "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };



    // Split a filename into [dir, root, basename, name, ext], unix version
    // 'root' is just a slash, or nothing.
    var splitPathRe =
        /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix = {};


    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }


    posix.parse = function(pathString) {
      if (typeof pathString !== 'string') {
        throw new TypeError(
            "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3],
      };
    };


    if (isWindows)
      module.exports = win32.parse;
    else /* posix */
      module.exports = posix.parse;

    module.exports.posix = posix.parse;
    module.exports.win32 = win32.parse;
    });
    pathParse.posix;
    pathParse.win32;

    var path = getCjsExportFromNamespace(_rollupPluginShim2);

    var parse = path.parse || pathParse;

    var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
        var prefix = '/';
        if ((/^([A-Za-z]:)/).test(absoluteStart)) {
            prefix = '';
        } else if ((/^\\\\/).test(absoluteStart)) {
            prefix = '\\\\';
        }

        var paths = [absoluteStart];
        var parsed = parse(absoluteStart);
        while (parsed.dir !== paths[paths.length - 1]) {
            paths.push(parsed.dir);
            parsed = parse(parsed.dir);
        }

        return paths.reduce(function (dirs, aPath) {
            return dirs.concat(modules.map(function (moduleDir) {
                return path.resolve(prefix, aPath, moduleDir);
            }));
        }, []);
    };

    var nodeModulesPaths = function nodeModulesPaths(start, opts, request) {
        var modules = opts && opts.moduleDirectory
            ? [].concat(opts.moduleDirectory)
            : ['node_modules'];

        if (opts && typeof opts.paths === 'function') {
            return opts.paths(
                request,
                start,
                function () { return getNodeModulesDirs(start, modules); },
                opts
            );
        }

        var dirs = getNodeModulesDirs(start, modules);
        return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };

    var normalizeOptions = function (x, opts) {
        /**
         * This file is purposefully a passthrough. It's expected that third-party
         * environments will override it at runtime in order to inject special logic
         * into `resolve` (by manipulating the options). One such example is the PnP
         * code path in Yarn.
         */

        return opts || {};
    };

    /* eslint no-invalid-this: 1 */

    var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = '[object Function]';

    var implementation = function bind(that) {
        var target = this;
        if (typeof target !== 'function' || toStr.call(target) !== funcType) {
            throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);

        var bound;
        var binder = function () {
            if (this instanceof bound) {
                var result = target.apply(
                    this,
                    args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;
            } else {
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );
            }
        };

        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

        if (target.prototype) {
            var Empty = function Empty() {};
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }

        return bound;
    };

    var functionBind = Function.prototype.bind || implementation;

    var src = functionBind.call(Function.call, Object.prototype.hasOwnProperty);

    var core$3 = {
    	assert: true,
    	"assert/strict": ">= 15",
    	async_hooks: ">= 8",
    	buffer_ieee754: "< 0.9.7",
    	buffer: true,
    	child_process: true,
    	cluster: true,
    	console: true,
    	constants: true,
    	crypto: true,
    	_debug_agent: ">= 1 && < 8",
    	_debugger: "< 8",
    	dgram: true,
    	diagnostics_channel: ">= 15.1",
    	dns: true,
    	"dns/promises": ">= 15",
    	domain: ">= 0.7.12",
    	events: true,
    	freelist: "< 6",
    	fs: true,
    	"fs/promises": [
    		">= 10 && < 10.1",
    		">= 14"
    	],
    	_http_agent: ">= 0.11.1",
    	_http_client: ">= 0.11.1",
    	_http_common: ">= 0.11.1",
    	_http_incoming: ">= 0.11.1",
    	_http_outgoing: ">= 0.11.1",
    	_http_server: ">= 0.11.1",
    	http: true,
    	http2: ">= 8.8",
    	https: true,
    	inspector: ">= 8.0.0",
    	_linklist: "< 8",
    	module: true,
    	net: true,
    	"node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
    	"node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
    	"node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
    	os: true,
    	path: true,
    	"path/posix": ">= 15.3",
    	"path/win32": ">= 15.3",
    	perf_hooks: ">= 8.5",
    	process: ">= 1",
    	punycode: true,
    	querystring: true,
    	readline: true,
    	repl: true,
    	smalloc: ">= 0.11.5 && < 3",
    	_stream_duplex: ">= 0.9.4",
    	_stream_transform: ">= 0.9.4",
    	_stream_wrap: ">= 1.4.1",
    	_stream_passthrough: ">= 0.9.4",
    	_stream_readable: ">= 0.9.4",
    	_stream_writable: ">= 0.9.4",
    	stream: true,
    	"stream/promises": ">= 15",
    	string_decoder: true,
    	sys: [
    		">= 0.6 && < 0.7",
    		">= 0.8"
    	],
    	timers: true,
    	"timers/promises": ">= 15",
    	_tls_common: ">= 0.11.13",
    	_tls_legacy: ">= 0.11.3 && < 10",
    	_tls_wrap: ">= 0.11.3",
    	tls: true,
    	trace_events: ">= 10",
    	tty: true,
    	url: true,
    	util: true,
    	"util/types": ">= 15.3",
    	"v8/tools/arguments": ">= 10 && < 12",
    	"v8/tools/codemap": [
    		">= 4.4.0 && < 5",
    		">= 5.2.0 && < 12"
    	],
    	"v8/tools/consarray": [
    		">= 4.4.0 && < 5",
    		">= 5.2.0 && < 12"
    	],
    	"v8/tools/csvparser": [
    		">= 4.4.0 && < 5",
    		">= 5.2.0 && < 12"
    	],
    	"v8/tools/logreader": [
    		">= 4.4.0 && < 5",
    		">= 5.2.0 && < 12"
    	],
    	"v8/tools/profile_view": [
    		">= 4.4.0 && < 5",
    		">= 5.2.0 && < 12"
    	],
    	"v8/tools/splaytree": [
    		">= 4.4.0 && < 5",
    		">= 5.2.0 && < 12"
    	],
    	v8: ">= 1",
    	vm: true,
    	wasi: ">= 13.4 && < 13.5",
    	worker_threads: ">= 11.7",
    	zlib: true
    };

    var core$4 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': core$3
    });

    var data$1 = getCjsExportFromNamespace(core$4);

    function specifierIncluded$1(current, specifier) {
    	var nodeParts = current.split('.');
    	var parts = specifier.split(' ');
    	var op = parts.length > 1 ? parts[0] : '=';
    	var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

    	for (var i = 0; i < 3; ++i) {
    		var cur = parseInt(nodeParts[i] || 0, 10);
    		var ver = parseInt(versionParts[i] || 0, 10);
    		if (cur === ver) {
    			continue; // eslint-disable-line no-restricted-syntax, no-continue
    		}
    		if (op === '<') {
    			return cur < ver;
    		}
    		if (op === '>=') {
    			return cur >= ver;
    		}
    		return false;
    	}
    	return op === '>=';
    }

    function matchesRange$1(current, range) {
    	var specifiers = range.split(/ ?&& ?/);
    	if (specifiers.length === 0) {
    		return false;
    	}
    	for (var i = 0; i < specifiers.length; ++i) {
    		if (!specifierIncluded$1(current, specifiers[i])) {
    			return false;
    		}
    	}
    	return true;
    }

    function versionIncluded$1(nodeVersion, specifierValue) {
    	if (typeof specifierValue === 'boolean') {
    		return specifierValue;
    	}

    	var current = typeof nodeVersion === 'undefined'
    		? process.versions && process.versions.node && process.versions.node
    		: nodeVersion;

    	if (typeof current !== 'string') {
    		throw new TypeError(typeof nodeVersion === 'undefined' ? 'Unable to determine current node version' : 'If provided, a valid node version is required');
    	}

    	if (specifierValue && typeof specifierValue === 'object') {
    		for (var i = 0; i < specifierValue.length; ++i) {
    			if (matchesRange$1(current, specifierValue[i])) {
    				return true;
    			}
    		}
    		return false;
    	}
    	return matchesRange$1(current, specifierValue);
    }



    var isCoreModule = function isCore(x, nodeVersion) {
    	return src(data$1, x) && versionIncluded$1(nodeVersion, data$1[x]);
    };

    var fs = getCjsExportFromNamespace(_rollupPluginShim1);

    var realpathFS$1 = fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;

    var defaultIsFile$1 = function isFile(file, cb) {
        fs.stat(file, function (err, stat) {
            if (!err) {
                return cb(null, stat.isFile() || stat.isFIFO());
            }
            if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
            return cb(err);
        });
    };

    var defaultIsDir$1 = function isDirectory(dir, cb) {
        fs.stat(dir, function (err, stat) {
            if (!err) {
                return cb(null, stat.isDirectory());
            }
            if (err.code === 'ENOENT' || err.code === 'ENOTDIR') return cb(null, false);
            return cb(err);
        });
    };

    var defaultRealpath = function realpath(x, cb) {
        realpathFS$1(x, function (realpathErr, realPath) {
            if (realpathErr && realpathErr.code !== 'ENOENT') cb(realpathErr);
            else cb(null, realpathErr ? x : realPath);
        });
    };

    var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
        if (opts && opts.preserveSymlinks === false) {
            realpath(x, cb);
        } else {
            cb(null, x);
        }
    };

    var defaultReadPackage = function defaultReadPackage(readFile, pkgfile, cb) {
        readFile(pkgfile, function (readFileErr, body) {
            if (readFileErr) cb(readFileErr);
            else {
                try {
                    var pkg = JSON.parse(body);
                    cb(null, pkg);
                } catch (jsonErr) {
                    cb(null);
                }
            }
        });
    };

    var getPackageCandidates$1 = function getPackageCandidates(x, start, opts) {
        var dirs = nodeModulesPaths(start, opts, x);
        for (var i = 0; i < dirs.length; i++) {
            dirs[i] = path.join(dirs[i], x);
        }
        return dirs;
    };

    var async = function resolve(x, options, callback) {
        var cb = callback;
        var opts = options;
        if (typeof options === 'function') {
            cb = opts;
            opts = {};
        }
        if (typeof x !== 'string') {
            var err = new TypeError('Path must be a string.');
            return process.nextTick(function () {
                cb(err);
            });
        }

        opts = normalizeOptions(x, opts);

        var isFile = opts.isFile || defaultIsFile$1;
        var isDirectory = opts.isDirectory || defaultIsDir$1;
        var readFile = opts.readFile || fs.readFile;
        var realpath = opts.realpath || defaultRealpath;
        var readPackage = opts.readPackage || defaultReadPackage;
        if (opts.readFile && opts.readPackage) {
            var conflictErr = new TypeError('`readFile` and `readPackage` are mutually exclusive.');
            return process.nextTick(function () {
                cb(conflictErr);
            });
        }
        var packageIterator = opts.packageIterator;

        var extensions = opts.extensions || ['.js'];
        var includeCoreModules = opts.includeCoreModules !== false;
        var basedir = opts.basedir || path.dirname(caller());
        var parent = opts.filename || basedir;

        opts.paths = opts.paths || [];

        // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
        var absoluteStart = path.resolve(basedir);

        maybeRealpath(
            realpath,
            absoluteStart,
            opts,
            function (err, realStart) {
                if (err) cb(err);
                else init(realStart);
            }
        );

        var res;
        function init(basedir) {
            if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
                res = path.resolve(basedir, x);
                if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
                if ((/\/$/).test(x) && res === basedir) {
                    loadAsDirectory(res, opts.package, onfile);
                } else loadAsFile(res, opts.package, onfile);
            } else if (includeCoreModules && isCoreModule(x)) {
                return cb(null, x);
            } else loadNodeModules(x, basedir, function (err, n, pkg) {
                if (err) cb(err);
                else if (n) {
                    return maybeRealpath(realpath, n, opts, function (err, realN) {
                        if (err) {
                            cb(err);
                        } else {
                            cb(null, realN, pkg);
                        }
                    });
                } else {
                    var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                    moduleError.code = 'MODULE_NOT_FOUND';
                    cb(moduleError);
                }
            });
        }

        function onfile(err, m, pkg) {
            if (err) cb(err);
            else if (m) cb(null, m, pkg);
            else loadAsDirectory(res, function (err, d, pkg) {
                if (err) cb(err);
                else if (d) {
                    maybeRealpath(realpath, d, opts, function (err, realD) {
                        if (err) {
                            cb(err);
                        } else {
                            cb(null, realD, pkg);
                        }
                    });
                } else {
                    var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                    moduleError.code = 'MODULE_NOT_FOUND';
                    cb(moduleError);
                }
            });
        }

        function loadAsFile(x, thePackage, callback) {
            var loadAsFilePackage = thePackage;
            var cb = callback;
            if (typeof loadAsFilePackage === 'function') {
                cb = loadAsFilePackage;
                loadAsFilePackage = undefined;
            }

            var exts = [''].concat(extensions);
            load(exts, x, loadAsFilePackage);

            function load(exts, x, loadPackage) {
                if (exts.length === 0) return cb(null, undefined, loadPackage);
                var file = x + exts[0];

                var pkg = loadPackage;
                if (pkg) onpkg(null, pkg);
                else loadpkg(path.dirname(file), onpkg);

                function onpkg(err, pkg_, dir) {
                    pkg = pkg_;
                    if (err) return cb(err);
                    if (dir && pkg && opts.pathFilter) {
                        var rfile = path.relative(dir, file);
                        var rel = rfile.slice(0, rfile.length - exts[0].length);
                        var r = opts.pathFilter(pkg, x, rel);
                        if (r) return load(
                            [''].concat(extensions.slice()),
                            path.resolve(dir, r),
                            pkg
                        );
                    }
                    isFile(file, onex);
                }
                function onex(err, ex) {
                    if (err) return cb(err);
                    if (ex) return cb(null, file, pkg);
                    load(exts.slice(1), x, pkg);
                }
            }
        }

        function loadpkg(dir, cb) {
            if (dir === '' || dir === '/') return cb(null);
            if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
                return cb(null);
            }
            if ((/[/\\]node_modules[/\\]*$/).test(dir)) return cb(null);

            maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {
                if (unwrapErr) return loadpkg(path.dirname(dir), cb);
                var pkgfile = path.join(pkgdir, 'package.json');
                isFile(pkgfile, function (err, ex) {
                    // on err, ex is false
                    if (!ex) return loadpkg(path.dirname(dir), cb);

                    readPackage(readFile, pkgfile, function (err, pkgParam) {
                        if (err) cb(err);

                        var pkg = pkgParam;

                        if (pkg && opts.packageFilter) {
                            pkg = opts.packageFilter(pkg, pkgfile);
                        }
                        cb(null, pkg, dir);
                    });
                });
            });
        }

        function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
            var cb = callback;
            var fpkg = loadAsDirectoryPackage;
            if (typeof fpkg === 'function') {
                cb = fpkg;
                fpkg = opts.package;
            }

            maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {
                if (unwrapErr) return cb(unwrapErr);
                var pkgfile = path.join(pkgdir, 'package.json');
                isFile(pkgfile, function (err, ex) {
                    if (err) return cb(err);
                    if (!ex) return loadAsFile(path.join(x, 'index'), fpkg, cb);

                    readPackage(readFile, pkgfile, function (err, pkgParam) {
                        if (err) return cb(err);

                        var pkg = pkgParam;

                        if (pkg && opts.packageFilter) {
                            pkg = opts.packageFilter(pkg, pkgfile);
                        }

                        if (pkg && pkg.main) {
                            if (typeof pkg.main !== 'string') {
                                var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');
                                mainError.code = 'INVALID_PACKAGE_MAIN';
                                return cb(mainError);
                            }
                            if (pkg.main === '.' || pkg.main === './') {
                                pkg.main = 'index';
                            }
                            loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                                if (err) return cb(err);
                                if (m) return cb(null, m, pkg);
                                if (!pkg) return loadAsFile(path.join(x, 'index'), pkg, cb);

                                var dir = path.resolve(x, pkg.main);
                                loadAsDirectory(dir, pkg, function (err, n, pkg) {
                                    if (err) return cb(err);
                                    if (n) return cb(null, n, pkg);
                                    loadAsFile(path.join(x, 'index'), pkg, cb);
                                });
                            });
                            return;
                        }

                        loadAsFile(path.join(x, '/index'), pkg, cb);
                    });
                });
            });
        }

        function processDirs(cb, dirs) {
            if (dirs.length === 0) return cb(null, undefined);
            var dir = dirs[0];

            isDirectory(path.dirname(dir), isdir);

            function isdir(err, isdir) {
                if (err) return cb(err);
                if (!isdir) return processDirs(cb, dirs.slice(1));
                loadAsFile(dir, opts.package, onfile);
            }

            function onfile(err, m, pkg) {
                if (err) return cb(err);
                if (m) return cb(null, m, pkg);
                loadAsDirectory(dir, opts.package, ondir);
            }

            function ondir(err, n, pkg) {
                if (err) return cb(err);
                if (n) return cb(null, n, pkg);
                processDirs(cb, dirs.slice(1));
            }
        }
        function loadNodeModules(x, start, cb) {
            var thunk = function () { return getPackageCandidates$1(x, start, opts); };
            processDirs(
                cb,
                packageIterator ? packageIterator(x, start, thunk, opts) : thunk()
            );
        }
    };

    var core$1 = {
    	assert: true,
    	"assert/strict": ">= 15",
    	async_hooks: ">= 8",
    	buffer_ieee754: "< 0.9.7",
    	buffer: true,
    	child_process: true,
    	cluster: true,
    	console: true,
    	constants: true,
    	crypto: true,
    	_debug_agent: ">= 1 && < 8",
    	_debugger: "< 8",
    	dgram: true,
    	diagnostics_channel: ">= 15.1",
    	dns: true,
    	"dns/promises": ">= 15",
    	domain: ">= 0.7.12",
    	events: true,
    	freelist: "< 6",
    	fs: true,
    	"fs/promises": [
    		">= 10 && < 10.1",
    		">= 14"
    	],
    	_http_agent: ">= 0.11.1",
    	_http_client: ">= 0.11.1",
    	_http_common: ">= 0.11.1",
    	_http_incoming: ">= 0.11.1",
    	_http_outgoing: ">= 0.11.1",
    	_http_server: ">= 0.11.1",
    	http: true,
    	http2: ">= 8.8",
    	https: true,
    	inspector: ">= 8.0.0",
    	_linklist: "< 8",
    	module: true,
    	net: true,
    	"node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
    	"node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
    	"node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
    	os: true,
    	path: true,
    	"path/posix": ">= 15.3",
    	"path/win32": ">= 15.3",
    	perf_hooks: ">= 8.5",
    	process: ">= 1",
    	punycode: true,
    	querystring: true,
    	readline: true,
    	repl: true,
    	smalloc: ">= 0.11.5 && < 3",
    	_stream_duplex: ">= 0.9.4",
    	_stream_transform: ">= 0.9.4",
    	_stream_wrap: ">= 1.4.1",
    	_stream_passthrough: ">= 0.9.4",
    	_stream_readable: ">= 0.9.4",
    	_stream_writable: ">= 0.9.4",
    	stream: true,
    	"stream/promises": ">= 15",
    	string_decoder: true,
    	sys: [
    		">= 0.6 && < 0.7",
    		">= 0.8"
    	],
    	timers: true,
    	"timers/promises": ">= 15",
    	_tls_common: ">= 0.11.13",
    	_tls_legacy: ">= 0.11.3 && < 10",
    	_tls_wrap: ">= 0.11.3",
    	tls: true,
    	trace_events: ">= 10",
    	tty: true,
    	url: true,
    	util: true,
    	"util/types": ">= 15.3",
    	"v8/tools/arguments": ">= 10 && < 12",
    	"v8/tools/codemap": [
    		">= 4.4.0 && < 5",
    		">= 5.2.0 && < 12"
    	],
    	"v8/tools/consarray": [
    		">= 4.4.0 && < 5",
    		">= 5.2.0 && < 12"
    	],
    	"v8/tools/csvparser": [
    		">= 4.4.0 && < 5",
    		">= 5.2.0 && < 12"
    	],
    	"v8/tools/logreader": [
    		">= 4.4.0 && < 5",
    		">= 5.2.0 && < 12"
    	],
    	"v8/tools/profile_view": [
    		">= 4.4.0 && < 5",
    		">= 5.2.0 && < 12"
    	],
    	"v8/tools/splaytree": [
    		">= 4.4.0 && < 5",
    		">= 5.2.0 && < 12"
    	],
    	v8: ">= 1",
    	vm: true,
    	wasi: ">= 13.4 && < 13.5",
    	worker_threads: ">= 11.7",
    	zlib: true
    };

    var core$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': core$1
    });

    var data = getCjsExportFromNamespace(core$2);

    var current = (process.versions && process.versions.node && process.versions.node.split('.')) || [];

    function specifierIncluded(specifier) {
        var parts = specifier.split(' ');
        var op = parts.length > 1 ? parts[0] : '=';
        var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');

        for (var i = 0; i < 3; ++i) {
            var cur = parseInt(current[i] || 0, 10);
            var ver = parseInt(versionParts[i] || 0, 10);
            if (cur === ver) {
                continue; // eslint-disable-line no-restricted-syntax, no-continue
            }
            if (op === '<') {
                return cur < ver;
            } else if (op === '>=') {
                return cur >= ver;
            } else {
                return false;
            }
        }
        return op === '>=';
    }

    function matchesRange(range) {
        var specifiers = range.split(/ ?&& ?/);
        if (specifiers.length === 0) { return false; }
        for (var i = 0; i < specifiers.length; ++i) {
            if (!specifierIncluded(specifiers[i])) { return false; }
        }
        return true;
    }

    function versionIncluded(specifierValue) {
        if (typeof specifierValue === 'boolean') { return specifierValue; }
        if (specifierValue && typeof specifierValue === 'object') {
            for (var i = 0; i < specifierValue.length; ++i) {
                if (matchesRange(specifierValue[i])) { return true; }
            }
            return false;
        }
        return matchesRange(specifierValue);
    }



    var core = {};
    for (var mod in data) { // eslint-disable-line no-restricted-syntax
        if (Object.prototype.hasOwnProperty.call(data, mod)) {
            core[mod] = versionIncluded(data[mod]);
        }
    }
    var core_1 = core;

    var isCore = function isCore(x) {
        return isCoreModule(x);
    };

    var realpathFS = fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;

    var defaultIsFile = function isFile(file) {
        try {
            var stat = fs.statSync(file);
        } catch (e) {
            if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
            throw e;
        }
        return stat.isFile() || stat.isFIFO();
    };

    var defaultIsDir = function isDirectory(dir) {
        try {
            var stat = fs.statSync(dir);
        } catch (e) {
            if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR')) return false;
            throw e;
        }
        return stat.isDirectory();
    };

    var defaultRealpathSync = function realpathSync(x) {
        try {
            return realpathFS(x);
        } catch (realpathErr) {
            if (realpathErr.code !== 'ENOENT') {
                throw realpathErr;
            }
        }
        return x;
    };

    var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
        if (opts && opts.preserveSymlinks === false) {
            return realpathSync(x);
        }
        return x;
    };

    var defaultReadPackageSync = function defaultReadPackageSync(readFileSync, pkgfile) {
        var body = readFileSync(pkgfile);
        try {
            var pkg = JSON.parse(body);
            return pkg;
        } catch (jsonErr) {}
    };

    var getPackageCandidates = function getPackageCandidates(x, start, opts) {
        var dirs = nodeModulesPaths(start, opts, x);
        for (var i = 0; i < dirs.length; i++) {
            dirs[i] = path.join(dirs[i], x);
        }
        return dirs;
    };

    var sync = function resolveSync(x, options) {
        if (typeof x !== 'string') {
            throw new TypeError('Path must be a string.');
        }
        var opts = normalizeOptions(x, options);

        var isFile = opts.isFile || defaultIsFile;
        var readFileSync = opts.readFileSync || fs.readFileSync;
        var isDirectory = opts.isDirectory || defaultIsDir;
        var realpathSync = opts.realpathSync || defaultRealpathSync;
        var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
        if (opts.readFileSync && opts.readPackageSync) {
            throw new TypeError('`readFileSync` and `readPackageSync` are mutually exclusive.');
        }
        var packageIterator = opts.packageIterator;

        var extensions = opts.extensions || ['.js'];
        var includeCoreModules = opts.includeCoreModules !== false;
        var basedir = opts.basedir || path.dirname(caller());
        var parent = opts.filename || basedir;

        opts.paths = opts.paths || [];

        // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
        var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);

        if ((/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/).test(x)) {
            var res = path.resolve(absoluteStart, x);
            if (x === '.' || x === '..' || x.slice(-1) === '/') res += '/';
            var m = loadAsFileSync(res) || loadAsDirectorySync(res);
            if (m) return maybeRealpathSync(realpathSync, m, opts);
        } else if (includeCoreModules && isCoreModule(x)) {
            return x;
        } else {
            var n = loadNodeModulesSync(x, absoluteStart);
            if (n) return maybeRealpathSync(realpathSync, n, opts);
        }

        var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;

        function loadAsFileSync(x) {
            var pkg = loadpkg(path.dirname(x));

            if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
                var rfile = path.relative(pkg.dir, x);
                var r = opts.pathFilter(pkg.pkg, x, rfile);
                if (r) {
                    x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
                }
            }

            if (isFile(x)) {
                return x;
            }

            for (var i = 0; i < extensions.length; i++) {
                var file = x + extensions[i];
                if (isFile(file)) {
                    return file;
                }
            }
        }

        function loadpkg(dir) {
            if (dir === '' || dir === '/') return;
            if (process.platform === 'win32' && (/^\w:[/\\]*$/).test(dir)) {
                return;
            }
            if ((/[/\\]node_modules[/\\]*$/).test(dir)) return;

            var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');

            if (!isFile(pkgfile)) {
                return loadpkg(path.dirname(dir));
            }

            var pkg = readPackageSync(readFileSync, pkgfile);

            if (pkg && opts.packageFilter) {
                // v2 will pass pkgfile
                pkg = opts.packageFilter(pkg, /*pkgfile,*/ dir); // eslint-disable-line spaced-comment
            }

            return { pkg: pkg, dir: dir };
        }

        function loadAsDirectorySync(x) {
            var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');
            if (isFile(pkgfile)) {
                try {
                    var pkg = readPackageSync(readFileSync, pkgfile);
                } catch (e) {}

                if (pkg && opts.packageFilter) {
                    // v2 will pass pkgfile
                    pkg = opts.packageFilter(pkg, /*pkgfile,*/ x); // eslint-disable-line spaced-comment
                }

                if (pkg && pkg.main) {
                    if (typeof pkg.main !== 'string') {
                        var mainError = new TypeError('package “' + pkg.name + '” `main` must be a string');
                        mainError.code = 'INVALID_PACKAGE_MAIN';
                        throw mainError;
                    }
                    if (pkg.main === '.' || pkg.main === './') {
                        pkg.main = 'index';
                    }
                    try {
                        var m = loadAsFileSync(path.resolve(x, pkg.main));
                        if (m) return m;
                        var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                        if (n) return n;
                    } catch (e) {}
                }
            }

            return loadAsFileSync(path.join(x, '/index'));
        }

        function loadNodeModulesSync(x, start) {
            var thunk = function () { return getPackageCandidates(x, start, opts); };
            var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();

            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                if (isDirectory(path.dirname(dir))) {
                    var m = loadAsFileSync(dir);
                    if (m) return m;
                    var n = loadAsDirectorySync(dir);
                    if (n) return n;
                }
            }
        }
    };

    async.core = core_1;
    async.isCore = isCore;
    async.sync = sync;

    var resolve = async;

    /* ****************************************************************************************************************** */
    // region: Module Vars & Ambients
    /* ****************************************************************************************************************** */
    var tsNodeIncluded = false;
    var requireStack = [];
    // endregion
    /* ****************************************************************************************************************** */
    // region: PluginCreator
    /* ****************************************************************************************************************** */
    /**
     * @example
     *
     * new PluginCreator([
     *   {transform: '@zerollup/ts-transform-paths', someOption: '123'},
     *   {transform: '@zerollup/ts-transform-paths', type: 'ls', someOption: '123'},
     *   {transform: '@zerollup/ts-transform-paths', type: 'ls', after: true, someOption: '123'}
     * ]).createTransformers({ program })
     */
    var PluginCreator = /** @class */ (function () {
        function PluginCreator(configs, resolveBaseDir) {
            var e_1, _a;
            if (resolveBaseDir === void 0) { resolveBaseDir = process.cwd(); }
            this.configs = configs;
            this.resolveBaseDir = resolveBaseDir;
            PluginCreator.validateConfigs(configs);
            try {
                // Support for deprecated 1.1 name
                for (var configs_1 = __values(configs), configs_1_1 = configs_1.next(); !configs_1_1.done; configs_1_1 = configs_1.next()) {
                    var config = configs_1_1.value;
                    if (config['beforeEmit'])
                        config.transformProgram = true;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (configs_1_1 && !configs_1_1.done && (_a = configs_1.return)) _a.call(configs_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        PluginCreator.prototype.mergeTransformers = function (into, source) {
            var _a, _b, _c;
            var slice = function (input) { return (Array.isArray(input) ? input.slice() : [input]); };
            if (source.before)
                (_a = into.before).push.apply(_a, __spreadArray([], __read(slice(source.before))));
            if (source.after)
                (_b = into.after).push.apply(_b, __spreadArray([], __read(slice(source.after))));
            if (source.afterDeclarations)
                (_c = into.afterDeclarations).push.apply(_c, __spreadArray([], __read(slice(source.afterDeclarations))));
            return this;
        };
        PluginCreator.prototype.createTransformers = function (params, customTransformers) {
            var e_2, _a;
            var transformers = { before: [], after: [], afterDeclarations: [] };
            var _b = __read(('ls' in params) ? [params.ls, params.ls.getProgram()] : [void 0, params.program], 2), ls = _b[0], program = _b[1];
            try {
                for (var _c = __values(this.configs), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var config = _d.value;
                    if (!config.transform || config.transformProgram)
                        continue;
                    var factory = this.resolveFactory(config);
                    if (factory === undefined)
                        continue;
                    this.mergeTransformers(transformers, PluginCreator.createTransformerFromPattern({ factory: factory, config: config, program: program, ls: ls }));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            // Chain custom transformers at the end
            if (customTransformers)
                this.mergeTransformers(transformers, customTransformers);
            return transformers;
        };
        PluginCreator.prototype.getProgramTransformers = function () {
            var e_3, _a;
            var res = [];
            try {
                for (var _b = __values(this.configs), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var config = _c.value;
                    if (!config.transform || !config.transformProgram)
                        continue;
                    var factory = this.resolveFactory(config);
                    if (factory === undefined)
                        continue;
                    res.push([factory, config]);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return res;
        };
        /* ***********************************************************
         * Helpers
         * ***********************************************************/
        PluginCreator.prototype.resolveFactory = function (config) {
            var _a;
            var tsConfig = config.tsConfig;
            var transform = config.transform;
            var importKey = config.import || 'default';
            /* Add support for TS transformers */
            var tsConfigCleanup;
            if (transform.match(/\.ts$/)) {
                // If tsConfig is specified and it differs, we need to re-register tsNode
                if (tsNodeIncluded && (tsConfig !== this.currentProject))
                    tsNodeIncluded = false;
                if (tsConfig)
                    tsConfig = path$1.resolve(this.resolveBaseDir, tsConfig);
                this.currentProject = tsConfig;
                if (!tsNodeIncluded) {
                    /* Try to add path mapping support, if paths specified */
                    var tsConfigData = void 0;
                    try {
                        tsConfigData = tsConfig && JSON.parse(fs$1.readFileSync(tsConfig, 'utf8'));
                    }
                    catch (_b) { }
                    if (tsConfig && ((_a = tsConfigData === null || tsConfigData === void 0 ? void 0 : tsConfigData.compilerOptions) === null || _a === void 0 ? void 0 : _a.paths)) {
                        try {
                            var tsConfigPaths = require('tsconfig-paths');
                            var absoluteBaseUrl = tsConfigPaths.loadConfig(tsConfig).absoluteBaseUrl;
                            tsConfigCleanup = tsConfigPaths.register({
                                baseUrl: absoluteBaseUrl,
                                paths: tsConfigData.compilerOptions.paths
                            });
                        }
                        catch (e) {
                            if (e.code === 'MODULE_NOT_FOUND')
                                console.warn("Warning: Paths specified in transformer tsconfig.json, but they can't be resolved. " +
                                    "Try adding 'tsconfig-paths' as a dev dependency");
                            else
                                throw e;
                        }
                    }
                    /* Register tsNode */
                    try {
                        require('ts-node').register(__assign(__assign({ transpileOnly: true }, (tsConfig ? { project: tsConfig } : { skipProject: true })), { compilerOptions: {
                                target: 'ES2018',
                                jsx: 'react',
                                esModuleInterop: true,
                                module: 'commonjs',
                            } }));
                        tsNodeIncluded = true;
                    }
                    catch (e) {
                        if (e.code === 'MODULE_NOT_FOUND')
                            throw new Error("Cannot use a typescript-based transformer without ts-node installed. " +
                                "Either add ts-node as a (dev)-dependency or install globally.");
                        else
                            throw e;
                    }
                }
            }
            var modulePath = resolve.sync(transform, { basedir: this.resolveBaseDir });
            /* Prevent recursive requiring of createTransformers (issue with ts-node) */
            if (requireStack.indexOf(modulePath) > -1)
                return;
            /* Load plugin */
            requireStack.push(modulePath);
            var commonjsModule = require(modulePath);
            requireStack.pop();
            // Un-register path mapping if in place
            tsConfigCleanup === null || tsConfigCleanup === void 0 ? void 0 : tsConfigCleanup();
            var factoryModule = (typeof commonjsModule === 'function') ? { default: commonjsModule } : commonjsModule;
            var factory = factoryModule[importKey];
            if (!factory)
                throw new Error("tsconfig.json > plugins: \"" + transform + "\" does not have an export \"" + importKey + "\": " +
                    require('util').inspect(factoryModule));
            if (typeof factory !== 'function') {
                throw new Error("tsconfig.json > plugins: \"" + transform + "\" export \"" + importKey + "\" is not a plugin: " +
                    require('util').inspect(factory));
            }
            return factory;
        };
        PluginCreator.validateConfigs = function (configs) {
            var e_4, _a;
            try {
                for (var configs_2 = __values(configs), configs_2_1 = configs_2.next(); !configs_2_1.done; configs_2_1 = configs_2.next()) {
                    var config = configs_2_1.value;
                    if (!config.name && !config.transform)
                        throw new Error('tsconfig.json plugins error: transform must be present');
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (configs_2_1 && !configs_2_1.done && (_a = configs_2.return)) _a.call(configs_2);
                }
                finally { if (e_4) throw e_4.error; }
            }
        };
        PluginCreator.createTransformerFromPattern = function (_a) {
            var factory = _a.factory, config = _a.config, program = _a.program, ls = _a.ls;
            var transform = config.transform, after = config.after, afterDeclarations = config.afterDeclarations; config.name; config.type; config.transformProgram; var cleanConfig = __rest(config, ["transform", "after", "afterDeclarations", "name", "type", "transformProgram"]);
            if (!transform)
                throw new Error('Not a valid config entry: "transform" key not found');
            var ret;
            switch (config.type) {
                case 'ls':
                    if (!ls)
                        throw new Error("Plugin " + transform + " needs a LanguageService");
                    ret = factory(ls, cleanConfig);
                    break;
                case 'config':
                    ret = factory(cleanConfig);
                    break;
                case 'compilerOptions':
                    ret = factory(program.getCompilerOptions(), cleanConfig);
                    break;
                case 'checker':
                    ret = factory(program.getTypeChecker(), cleanConfig);
                    break;
                case undefined:
                case 'program':
                    var _b = diagnosticExtrasFactory(program), addDiagnostic = _b.addDiagnostic, removeDiagnostic = _b.removeDiagnostic, diagnostics = _b.diagnostics;
                    ret = factory(program, cleanConfig, {
                        ts: ts,
                        addDiagnostic: addDiagnostic,
                        removeDiagnostic: removeDiagnostic,
                        diagnostics: diagnostics,
                        library: getCurrentLibrary()
                    });
                    break;
                case 'raw':
                    ret = function (ctx) { return factory(ctx, program, cleanConfig); };
                    break;
                default:
                    throw new Error("Invalid plugin type found in tsconfig.json: '" + config.type + "'");
            }
            if (typeof ret === 'function')
                return after ? ({ after: ret }) :
                    afterDeclarations ? ({ afterDeclarations: ret }) :
                        { before: ret };
            return ret;
        };
        return PluginCreator;
    }());
    // endregion

    /*
     * The logic in this file is based on TTypescript (https://github.com/cevek/ttypescript)
     * Credit & thanks go to cevek (https://github.com/cevek) for the incredible work!
     */
    /* ****************************************************************************************************************** */
    // region: Constants & Ambients
    /* ****************************************************************************************************************** */
    var activeProgramTransformers = new Set();
    var dirname = require('path').dirname;
    // endregion
    /* ****************************************************************************************************************** */
    // region: Helpers
    /* ****************************************************************************************************************** */
    function getProjectDir(compilerOptions) {
        return compilerOptions.configFilePath && dirname(compilerOptions.configFilePath);
    }
    function getProjectConfig(compilerOptions, rootFileNames) {
        var configFilePath = compilerOptions.configFilePath;
        var projectDir = getProjectDir(compilerOptions);
        if (configFilePath === undefined) {
            var baseDir = (rootFileNames.length > 0) ? dirname(rootFileNames[0]) : projectDir !== null && projectDir !== void 0 ? projectDir : process.cwd;
            configFilePath = ts.findConfigFile(baseDir, ts.sys.fileExists);
            if (configFilePath) {
                var config = readConfig(configFilePath);
                compilerOptions = __assign(__assign({}, config.options), compilerOptions);
                projectDir = getProjectDir(compilerOptions);
            }
        }
        return ({ projectDir: projectDir, compilerOptions: compilerOptions });
    }
    function readConfig(configFileNamePath) {
        var projectDir = dirname(configFileNamePath);
        var result = ts.readConfigFile(configFileNamePath, ts.sys.readFile);
        if (result.error)
            throw new Error('Error in tsconfig.json: ' + result.error.messageText);
        return ts.parseJsonConfigFileContent(result.config, ts.sys, projectDir, undefined, configFileNamePath);
    }
    function preparePluginsFromCompilerOptions(plugins) {
        if (!plugins)
            return [];
        // Old transformers system
        if ((plugins.length === 1) && plugins[0].customTransformers) {
            var _a = plugins[0].customTransformers, _b = _a.before, before = _b === void 0 ? [] : _b, _c = _a.after, after = _c === void 0 ? [] : _c;
            return __spreadArray(__spreadArray([], __read(before.map(function (item) { return ({ transform: item }); }))), __read(after.map(function (item) { return ({ transform: item, after: true }); })));
        }
        return plugins;
    }
    // endregion
    /* ****************************************************************************************************************** */
    // region: createProgram - (patched method)
    /* ****************************************************************************************************************** */
    function createProgram(rootNamesOrOptions, options, host, oldProgram, configFileParsingDiagnostics) {
        var e_1, _a, e_2, _b;
        var _c;
        var rootNames;
        /* Determine options */
        var createOpts = !Array.isArray(rootNamesOrOptions) ? rootNamesOrOptions : void 0;
        if (createOpts) {
            rootNames = createOpts.rootNames;
            options = createOpts.options;
            host = createOpts.host;
            oldProgram = createOpts.oldProgram;
            configFileParsingDiagnostics = createOpts.configFileParsingDiagnostics;
        }
        else {
            options = options;
            rootNames = rootNamesOrOptions;
        }
        /* Get Config */
        var projectConfig = getProjectConfig(options, rootNames);
        if (isTSC) {
            options = projectConfig.compilerOptions;
            if (createOpts)
                createOpts.options = options;
        }
        /* Invoke TS createProgram */
        var program = createOpts ?
            ts.originalCreateProgram(createOpts) :
            ts.originalCreateProgram(rootNames, options, host, oldProgram, configFileParsingDiagnostics);
        /* Prepare Plugins */
        var plugins = preparePluginsFromCompilerOptions(options.plugins);
        var pluginCreator = new PluginCreator(plugins, (_c = projectConfig.projectDir) !== null && _c !== void 0 ? _c : process.cwd());
        /* Prevent recursion in Program transformers */
        var programTransformers = new Map(pluginCreator.getProgramTransformers());
        try {
            for (var _d = __values(pluginCreator.getProgramTransformers()), _e = _d.next(); !_e.done; _e = _d.next()) {
                var _f = __read(_e.value, 1), transformer = _f[0];
                if (activeProgramTransformers.has(transformer))
                    programTransformers.delete(transformer);
                else
                    activeProgramTransformers.add(transformer);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            /* Transform Program */
            for (var programTransformers_1 = __values(programTransformers), programTransformers_1_1 = programTransformers_1.next(); !programTransformers_1_1.done; programTransformers_1_1 = programTransformers_1.next()) {
                var _g = __read(programTransformers_1_1.value, 2), programTransformer = _g[0], config = _g[1];
                var newProgram = programTransformer(program, host, config, { ts: ts });
                if (typeof (newProgram === null || newProgram === void 0 ? void 0 : newProgram['emit']) === 'function')
                    program = newProgram;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (programTransformers_1_1 && !programTransformers_1_1.done && (_b = programTransformers_1.return)) _b.call(programTransformers_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        programTransformers.forEach(function (c, transformer) { return activeProgramTransformers.delete(transformer); });
        /* Hook emit method */
        if (!program.originalEmit) {
            program.originalEmit = program.emit;
            program.emit = newEmit;
        }
        function newEmit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) {
            var e_3, _a;
            var additionalArgs = [];
            for (var _i = 5; _i < arguments.length; _i++) {
                additionalArgs[_i - 5] = arguments[_i];
            }
            /* Merge in our transformers */
            var transformers = pluginCreator.createTransformers({ program: program }, customTransformers);
            /* Invoke TS emit */
            var result = program.originalEmit.apply(program, __spreadArray([targetSourceFile,
                writeFile,
                cancellationToken,
                emitOnlyDtsFiles,
                transformers], __read(additionalArgs)));
            try {
                /* Merge in transformer diagnostics */
                for (var _b = __values(diagnosticMap.get(program) || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var diagnostic = _c.value;
                    if (!result.diagnostics.includes(diagnostic))
                        result.diagnostics.push(diagnostic);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return result;
        }
        return program;
    }
    // endregion

    /*
     * Note: This file is used to generate module-patch.js (see rollup.config.js)
     */
    /* ********************************************************************************************************************
     * Link to ts object
     * ********************************************************************************************************************/
    Object.assign(ts, {
        tspVersion: tspVersion,
        PluginCreator: PluginCreator,
        originalCreateProgram: ts.createProgram,
        createProgram: createProgram,
        diagnosticMap: diagnosticMap
    });

}());
